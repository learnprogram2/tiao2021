


介绍自己: = 你的价值, 为公司你解决什么问题？
What in it for them.

success: I have been xxx
strength: 强项, 擅长.
situation: 应用上面的应用在当前: what i am looking for is xxx 怎样在当前工作上xxxx.




### 个人情况
1. 工作角色是什么, 如何学习?


### 项目相关
1.

#### 1. 积分商城项目

#### 2. live-live高可用项目













### Java相关
1. 线程池有哪些常用的? 适用场景是什么?
    1. 定时检查的这种使用频率不高的任务: Timer, 用一个线程+DelayQueue(PriorityQueue)实现的
    2. 普通的多线程场景: ThreadPool, 7参数的: 核心线程, 最大线程数, keepalive时间+unit, 任务队列, 线程工厂, 拒绝策略.
    3. 多个定时任务, 可以用Timer的多线程版, 线程池+DelayQueue.
    4. Cache模式的线程池, 使用SynchronizedQueue, 提交任务必须有线程对接. 线程容易飙升.
2. 延迟队列的实现方式:
    1. 最小堆+JUC的lock组件: DelayQueue
    2. 时间轮:
    3. 跳表: redis的zset
    4. 分桶有序排队策略: 支持特定的延时时间段, RocketMQ的延迟队列. 设计简单
4. Kafka和Netty的时间轮实现有什么区别?
    Kafka采用多级轮, 使用DelayQueue存储轮cell, 减少了遍历次数.
    Netty采用单轮+轮数
5. JVM内存分配, 执行原理, 类加载过程
    内存分配: Heap, 虚拟机栈, 元数据区, 本地方法栈, 程序技术区.
        Heap: 存储所有的对象, 字符串常量
        虚拟机栈: 存储线程执行的私有数据, 对象指针, 表.
        元数据区: 存放在本地内存, 不属于JVM内, 存储常量, class对象..
        本地方法栈+程序计数区: native线程的栈, 线程执行进度.

    类加载过程: 加载(加载文件, 创建class对象) -> 验证(class文件规范) -> 准备:类变量分配空间, 初始null值 -> 解析:修改符号引用到直接引用 -> 初始化:创建对象 -> 使用 -> 卸载

6. 常用GC收集器? 用的什么? 对CMS有优化么? G1的工作原理?
    常用GC收集器:
        单线程: serial, serialOld
        多线程: parNew, parOld
        复合: CMS, G1
    使用: CMS+ParNew 一个组合, 或者G1
    CMS原理和优化:
        四个阶段:
            初始标记: STW, GCroot找到所有直接引用的
            并发标记: 对老年代所有对象进行gcRoot追踪
            重新标记: STW, 对第二阶段的新对象, 进行gcRoot追踪
            并发清除: 很耗时
        优化:
            取消每次FullTC的内存碎片整理: -XXCMSFullGCsBeforeCompaction=5 5次一整理
            ???
    G1的工作原理:
        雷同CMS的分代策略, 只是分region, 128mb一个, region可以动态规划到新生代, 老年代.
        通过region的区分, 可以做到预估回收的效率和价值, 做到可控STW.
        回收流程类似CMS, 使用复制算法. 而不是标记清除算法.

7. 线上机器CPU负载过高如何排查? 如何优化JVM参数
    CPU排查:
        1. 先Top查看cup最高的进程, 然后top-H查看进程占用CPU最高的线程.
        2. 使用jps查看jvm的线程状态, 使用jstack查看线程栈信息, 对应代码看一下瓶颈在哪里.
    JVM参数优化:
        1. 先找到JVM的瓶颈, 高峰时候可以用jps每秒输出, 查看各个区域的内存变化, 来估算瓶颈在哪里.
        2. 找到瓶颈后, 对应的, 把内存各个区域的大小和比例调整一下, 然后如果有GC问题就调整一下GC的清理要求, 别搞太多的损耗.
        3. 如果有OOM问题, 就dump出来, MAT分析一下, 查看堆栈和对象都是什么.

8. 线上机器不断FullGC, 如何排查?
    先用jps看对象生成速率, 和Heap各区域之间的对象满的情况
    调整各区域大小, 或者是dump一下, 看一下都是什么对象, 对照业务, 看一下如何优化.

9. 线上OOM情况? 如何排查?
    Flink平台的大state, 会因为申请堆外内存过多, 被K8s杀掉. 要调整k8s.

10. 如何让Metaspace区OOM?
    很难, 因为挪到了内存里面.
    循环创建class对象可能可以. Metaspace的空间占用达到了设定的最大值就会fullGC.

11. JVM优化? 优化点有哪些? 如何考虑?


12. Tomcat非阻塞协议和阻塞协议的区别

13. Nio的底层原理? 系统epoll是如何实现的?
    Nio底层依赖操作系统的多路复用IO实现, 多路复用属于同步阻塞IO, 内核同步响应数据, 进程阻塞收取, 但是多路复用可以极大提高收发包效率.
    操作系统有5中IO模型:
        1. 阻塞IO: 单个文件要一个线程, 阻塞同步拿数据.
        2. 非阻塞IO: 单线程要轮询拿取, 同步非阻塞.
        3. 多路复用: 内核同步读写, 阻塞拿去, 但是一个selector维护多个文件.
            实现: select, poll, epoll.
                select有fd大小限制, poll链表实现突破限制. epoll在fd就绪时候会到一个就绪链表里, 避免遍历所有fd.
                网卡写入数据帧, 硬中断cpu, cpu软中断使用内核线程收数据, 然后解析TCP, 查找socket, 唤醒socket的等待队列函数, 就是epoll函数
                epoll函数把socket放在epoll的就绪队列里, selector遍历时候就会被唤醒.
        4. 信号驱动IO
        5. 异步IO: 异步回调.

14. Nio是边缘触发还是水平触发?
    Java Nio水平触发: 只要满足, 不断地触发时间
    水平触发: level-trigger, 信号只需要满足条件, 就一直会触发.
        epoll是以缓冲区空满状态来判断水平触发条件. 如果缓冲区有数据, 就一直触发读事件. 只要缓冲区还不满, 就一直触发写事件.
    边缘触发: edge-trigger, 当状态边缘变化时候触发一个事件.
        Linux的epoll也支持边缘触发, 在文件就绪时候, 会叫醒epoll的selector

15. Nio的epoll实现, 如何打断一个select()方法?
    wakeup()

16. 什么场景下使用DirectBuffer? 使用Heap去进行IO读写时, 为什么申请临时的DirectBuffer进行数据拷贝?
    需要和内核打交道的时候, 使用DirectBuffer会减少一次内存拷贝. HeapBuffer要多做一次, 而且增加GC压力.

17. Nio的零拷贝如何实现?
    JavaNino零拷贝, fileChannel的的transferTo()基于sendfile实现, mmap适合小数据量读写, 直接在内核操作.
    sendfile还可以利用DMA来优化, 减少拷贝次数.

18. 单例模式double check时候的volatile的作用是?
    防止指令重排, 因为在synchronized里面还是会发生指令重排的.
    volatile加入loadstore写屏障, 实现了有序性. 可见性也保证了.

19. 讲一下synchronized锁升级?
    早期的synchronized都是重量锁.
    1. 偏向锁:
    2. 轻量级锁:
    3. 自旋优化:
    4. 重量级锁:

20. synchronized保证可见性:
    monitorenter, 集成了内存屏障.
    load(refresh), store(flush) 内存屏障, 拿到最新数据
    acquire, release屏障禁止读/写和读写重排

21. 并发编程时, wait()调用要放在while()循环里?  什么情况会造成假唤醒?
        while (product >=1) {
            try {
                this.wait();
            }
        }
        while 保证唤醒之后, 如果不满足条件还会睡过去. 避免假唤醒.
        假唤醒就是醒来发现, 没有满足条件, 白干活, 如果没处理还会造成数据不一致.

22. HashMap如何解决Hash冲突?
    首先 hashMap对hash算法进行散列, 使用前后16位的亦或来分散.
    如果hashMap的hash冲突, 会用单向链表, 避免扩容使用头插法死循环, 换用拆分链表.


### 微服务
1. 你们的系统如何设计, 为什么要重构为微服务架构?
    系统最初就是javaWeb项目的三层架构: UI层(MVC), 业务层(Service), 数据库层(DAO)
    spring-MVC, spring, MyBatis技术栈开发.
    但单体项目开发到后面太复杂了, 不能满足敏捷开发, 多个人业务分工, 还有业务的单独需求(有的需要高并发, 有的没必要).
    就进行业务拆分, 拆分成多个子服务, 通过RPC框架联合成有机的一个微服务架构. 并在多个部门之间通过分布式中间件, 搭建起庞大的微服务生态系统, 满足业务需求.
    所以主要是 为了突破单体项目局限, 满足多团队敏捷开发, 和多业务的需求.

2. 微服务框架用的是什么? 为什么选择这个?
    我们用的spring-cloud, 主要是生态比较好, 除了基础的RPC功能外, 还有最初的netflix体系, 整合了微服务里面的负载均衡, 注解式调用, 限流熔断, 注册发现等内容.
    dubbo作为一个分布式服务框架, 需要自己定制很多, 所以以后有转spring-cloud-alibaba体系.
    因为微服务主要是开发业务的, 其他各种功能主要考虑方便和可靠的均衡, 如果是单纯的rpc调用的话, 用grpc比较好, 比如我们之前的文件存储系统和注册中心系统, 都是通过grpc互相调用的, ProtoBuf序列化协议比较快.
        事实上eureka用的是一个restful的框架jerssy, 适合就好. 方便, 功能合适.
    dubbo vs spring-cloud: Dubbo 是 SOA(service oriented architecture) 时代的产物, 它的关注点主要在于服务调用, 流量分发, 流量监控和熔断.
        Spring Cloud 诞生于微服务架构时代, 考虑的是微服务治理的方方面面, 另外由于依托Spring, Spring Boot 的优势之上, Dubbo 定位服务治理 属于 Spring Cloud 生态体系里面

    单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密封装。
    一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个或多个协调某些活动的服务。
    微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。

3. 服务化之后, 会遇到什么样的问题? 解决方案是什么?
    微服务架构主要遇到的是共享数据的问题.
    1. 技术门槛高, 复杂性增加: 服务描述, 注册中心, 服务框架, 服务监控, 服务追踪, 服务治理等几大基本组件
    2. RPC 依赖网络IO调用的不确定性: 限流, 降级, 熔断.
    3. 分布式共享数据的一致性问题: 分布式事务, 分布式锁.
    4. 服务治理, 依赖的传递性: spring-cloud-admin-portal 治理.

4. 你们的系统中, 限流熔断组件时用的是什么? 网关用的是什么? 说一下请求流程?
    用的Hystrix小刺猬, 他是circubreaker+workPool的实现
    网关用的zuul, 就是web容器的filter实现, 加上了eureka+hystrix+ribbon把流量均衡的接入微服务.

5. Hystrix是如何限流的?
    1. hystrix通过ribbon的springContext接入到每个服务之中
    2. 对于每个serviceId, hystrix设置了一个group配置, 配置了workpool的大小, 是并行度上限.
    3. 对于每个请求, 包装在一个HystrixCommand里面, 使用observer流式编程, 包装了一个执行链条.
    4. hystrixCommand放到workPool里面执行, 就起到了限流的作用, 执行链条相关的每一个serviceId有一个circuitBreaker, 起到熔断,
        执行链条内包装了降级的执行.

6. Eureka多级缓存导致的时效差?
    Eureka里面查询有一个两级缓存, 包装了每一个key的响应. EurekaPeer之间同步, 有一个三级缓存队列, 包装多个request成一个package.
    1. 第一层读写缓存其实是和registry同步的, 没有时差, 每次registry修改后都会失效这层缓存, 用的是google的一个工具Map.
    2. 第二层缓存对每一个key有一个30s的过期缓存, 所以查询里缓存导致的时差主要是这30s.
    3. peer同步的package打包三级缓存, 主要是队列, 有package的request条数和过期时间的限制, 应该是500ms一个batch.

7. spring-cloud-netflix有些功能比较老, 为什么不用spring-cloud-alibaba?
    稳定, netflix退出之后, 也更倾向于用spring-cloud官方的组件: https://i0.hdslb.com/bfs/article/ed3f92808d9fde1b1de5e126c6d8fb02bb7841ee.png@942w_539h_progressive.webp
    service-discovery, circuitBreaker, openFeign, gateway, loadBalancer.

8. netflix 对比 alibaba有哪些区别?
    区别就是组件不一样.

9. nacos和eureka相比有什么不同?
    Eureka是侧重于ap的注册中心, 没有严格保证一致性, 通过过期时间+心跳+peer同步(最新覆盖最老的)来保证最终一致性
    Nacos=注册中心+配置中心, 结合了MySQL实现了CP和AP

10. sentinel如何持久化降级策略的?
11. Sentinel的工作原理? 动态限流如何实现的? 和hystrix对比?

12. spring-cloud的微服务, 有灰度发布么? 平时是怎么发布的?
    可以通过zuul网关的转发策略, 来实现灰度发布, eureka的metamata里面配置服务的键值对.
    版本发布:
        1. 优雅关闭:
            1. actuator的shutdown命令, 取消注册, JDK的shutdownHook, 直接kill-15容器.
                都是向jvm发出shutdown命令\
            2. spring注册shutdownHook, 注册一个监听器线程, 满足条件时执行doClose方法, 关闭spring, jvm就关闭了.

13. Feign的执行过程? 为什么默认参数有问题?
    执行过程:
        1. 嵌入Spring-Boot体系: 为每一个serviceId配置一个springContext, 里面配置这feignClient的配置参数.
        2. spring启动: 扫描@FeignClient注解, 通过配置的serviceId的spring配置, 为每一个接口生成一个动态代理InvocationHandler.
        3. 在执行调用的时候, 请求通过对应的动态代理, 通过spring里面为serviceId配置的Ribbon的ILoadBalacener, 里面包装了zoneAwareEurekaClient, 可以拿到目标地址
        4. ribbon的encoder和decoder, 包装好请求, 最后通过HttpClient发出去, 接收.
    默认参数:
        超时时间太短, 默认懒加载, 初次调用都会启动一个spring, 可能会超时.

14. 线上微服务部署, 一台机器负载过高, 如何处理?












