


介绍自己: = 你的价值, 为公司你解决什么问题？
What in it for them.

success: I have been xxx
strength: 强项, 擅长.
situation: 应用上面的应用在当前: what i am looking for is xxx 怎样在当前工作上xxxx.




### 个人情况
1. 工作角色是什么, 如何学习?


### 项目相关
1.

#### 1. 积分商城项目

#### 2. live-live高可用项目













### Java相关
1. 线程池有哪些常用的? 适用场景是什么?
    1. 定时检查的这种使用频率不高的任务: Timer, 用一个线程+DelayQueue(PriorityQueue)实现的
    2. 普通的多线程场景: ThreadPool, 7参数的: 核心线程, 最大线程数, keepalive时间+unit, 任务队列, 线程工厂, 拒绝策略.
    3. 多个定时任务, 可以用Timer的多线程版, 线程池+DelayQueue.
    4. Cache模式的线程池, 使用SynchronizedQueue, 提交任务必须有线程对接. 线程容易飙升.
2. 延迟队列的实现方式:
    1. 最小堆+JUC的lock组件: DelayQueue
    2. 时间轮:
    3. 跳表: redis的zset
    4. 分桶有序排队策略: 支持特定的延时时间段, RocketMQ的延迟队列. 设计简单
4. Kafka和Netty的时间轮实现有什么区别?
    Kafka采用多级轮, 使用DelayQueue存储轮cell, 减少了遍历次数.
    Netty采用单轮+轮数
5. JVM内存分配, 执行原理, 类加载过程
    内存分配: Heap, 虚拟机栈, 元数据区, 本地方法栈, 程序技术区.
        Heap: 存储所有的对象, 字符串常量
        虚拟机栈: 存储线程执行的私有数据, 对象指针, 表.
        元数据区: 存放在本地内存, 不属于JVM内, 存储常量, class对象..
        本地方法栈+程序计数区: native线程的栈, 线程执行进度.

    类加载过程: 加载(加载文件, 创建class对象) -> 验证(class文件规范) -> 准备:类变量分配空间, 初始null值 -> 解析:修改符号引用到直接引用 -> 初始化:创建对象 -> 使用 -> 卸载

6. 常用GC收集器? 用的什么? 对CMS有优化么? G1的工作原理?
    常用GC收集器:
        单线程: serial, serialOld
        多线程: parNew, parOld
        复合: CMS, G1
    使用: CMS+ParNew 一个组合, 或者G1
    CMS原理和优化:
        四个阶段:
            初始标记: STW, GCroot找到所有直接引用的
            并发标记: 对老年代所有对象进行gcRoot追踪
            重新标记: STW, 对第二阶段的新对象, 进行gcRoot追踪
            并发清除: 很耗时
        优化:
            取消每次FullTC的内存碎片整理: -XXCMSFullGCsBeforeCompaction=5 5次一整理
            ???
    G1的工作原理:
        雷同CMS的分代策略, 只是分region, 128mb一个, region可以动态规划到新生代, 老年代.
        通过region的区分, 可以做到预估回收的效率和价值, 做到可控STW.
        回收流程类似CMS, 使用复制算法. 而不是标记清除算法.

7. 线上机器CPU负载过高如何排查? 如何优化JVM参数
    CPU排查:
        1. 先Top查看cup最高的进程, 然后top-H查看进程占用CPU最高的线程.
        2. 使用jps查看jvm的线程状态, 使用jstack查看线程栈信息, 对应代码看一下瓶颈在哪里.
    JVM参数优化:
        1. 先找到JVM的瓶颈, 高峰时候可以用jps每秒输出, 查看各个区域的内存变化, 来估算瓶颈在哪里.
        2. 找到瓶颈后, 对应的, 把内存各个区域的大小和比例调整一下, 然后如果有GC问题就调整一下GC的清理要求, 别搞太多的损耗.
        3. 如果有OOM问题, 就dump出来, MAT分析一下, 查看堆栈和对象都是什么.

8. 线上机器不断FullGC, 如何排查?
    先用jps看对象生成速率, 和Heap各区域之间的对象满的情况
    调整各区域大小, 或者是dump一下, 看一下都是什么对象, 对照业务, 看一下如何优化.

9. 线上OOM情况? 如何排查?
    Flink平台的大state, 会因为申请堆外内存过多, 被K8s杀掉. 要调整k8s.

10. 如何让Metaspace区OOM?
    很难, 因为挪到了内存里面.
    循环创建class对象可能可以. Metaspace的空间占用达到了设定的最大值就会fullGC.

11. JVM优化? 优化点有哪些? 如何考虑?


12. Tomcat非阻塞协议和阻塞协议的区别

13. Nio的底层原理? 系统epoll是如何实现的?
    Nio底层依赖操作系统的多路复用IO实现, 多路复用属于同步阻塞IO, 内核同步响应数据, 进程阻塞收取, 但是多路复用可以极大提高收发包效率.
    操作系统有5中IO模型:
        1. 阻塞IO: 单个文件要一个线程, 阻塞同步拿数据.
        2. 非阻塞IO: 单线程要轮询拿取, 同步非阻塞.
        3. 多路复用: 内核同步读写, 阻塞拿去, 但是一个selector维护多个文件.
            实现: select, poll, epoll.
                select有fd大小限制, poll链表实现突破限制. epoll在fd就绪时候会到一个就绪链表里, 避免遍历所有fd.
                网卡写入数据帧, 硬中断cpu, cpu软中断使用内核线程收数据, 然后解析TCP, 查找socket, 唤醒socket的等待队列函数, 就是epoll函数
                epoll函数把socket放在epoll的就绪队列里, selector遍历时候就会被唤醒.
        4. 信号驱动IO
        5. 异步IO: 异步回调.

14. Nio是边缘触发还是水平触发?
    Java Nio水平触发: 只要满足, 不断地触发时间
    水平触发: level-trigger, 信号只需要满足条件, 就一直会触发.
        epoll是以缓冲区空满状态来判断水平触发条件. 如果缓冲区有数据, 就一直触发读事件. 只要缓冲区还不满, 就一直触发写事件.
    边缘触发: edge-trigger, 当状态边缘变化时候触发一个事件.
        Linux的epoll也支持边缘触发, 在文件就绪时候, 会叫醒epoll的selector

15. Nio的epoll实现, 如何打断一个select()方法?
    wakeup()

16. 什么场景下使用DirectBuffer? 使用Heap去进行IO读写时, 为什么申请临时的DirectBuffer进行数据拷贝?
    需要和内核打交道的时候, 使用DirectBuffer会减少一次内存拷贝. HeapBuffer要多做一次, 而且增加GC压力.

17. Nio的零拷贝如何实现?
    JavaNino零拷贝, fileChannel的的transferTo()基于sendfile实现, mmap适合小数据量读写, 直接在内核操作.
    sendfile还可以利用DMA来优化, 减少拷贝次数.

18. 单例模式double check时候的volatile的作用是?
    防止指令重排, 因为在synchronized里面还是会发生指令重排的.
    volatile加入loadstore写屏障, 实现了有序性. 可见性也保证了.

19. 讲一下synchronized锁升级?
    早期的synchronized都是重量锁.
    1. 偏向锁:
    2. 轻量级锁:
    3. 自旋优化:
    4. 重量级锁:

20. synchronized保证可见性:
    monitorenter, 集成了内存屏障.
    load(refresh), store(flush) 内存屏障, 拿到最新数据
    acquire, release屏障禁止读/写和读写重排

21. 并发编程时, wait()调用要放在while()循环里?  什么情况会造成假唤醒?


















