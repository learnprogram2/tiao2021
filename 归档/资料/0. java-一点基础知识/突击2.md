### 02. TCP/IP四层 / OSI七层网络模型

- **ms官心理:**

  **结构化ms三个分为: 基础, 架构设计, 项目经验**

- OSI七层协议: 统一的协定:

  (应用层-表示层-会话层)-传输层-网络-数据链路层-物理层

- **TCP/IP 四层:**

  **数据链路->传输层->网络层->应用层**

  1. **物理层:** 光纤, 网线...

  2. **数据链路层:** 规定物理层传递的01信号如何分组, 描述source和target(网卡mac地址48位2进制/12个16进制). - **以太网协议:** 把电信号分组成帧(frame), 每个帧分为head和data, head是metedata: 描述和source+target和数据类型...

     网卡会把帧广播给子网里所有机器(网卡), 接收的网卡看是不是自己的.  但是怎么知道是不是一个子网的? 就需要网络层

  3. **网络层:** **IP协议,** 每个计算机都会分配一个IP地址, 32位(24位代表网络, 后8位代表主机). IP地址+子网掩码就可以确定子网和公网的界限了.

     子网掩码和IP地址做与运算, 就剩下ip前面的代表网络的部分, 这样就可以对比两个ip前代表网络部分是否相同(是否属于同一子网)

     - 两个子网交互: **路由器使用公网(大子网)的交换机和cache连接两个子网,** 在帧里面写target地址为自己的路由器mac地址. 路由器把frame要发送的ip从cache里面拿出mac地址, 修改target改成目标网卡的mac地址, 然后在自己所在的更大子网传递到能找到对方子网的交换机, 进行广播找到对方. 
     - **子网内交互: 通过交换机(使用mac)在子网内广播frame.** 
     - ARP(address resolution protocol)协议: 互联网中广播自己的mac和ip地址, 然后每个路由器都有其他机器的ip-mac地址cache.通过IP来定位mac地址. [图解ARP](https://zhuanlan.zhihu.com/p/28771785)
     - 交换机通过mac和arp实现局域网内互联, 路由器通过IP实现全网段互联.

  4. **传输层:** TCP协议, 端口间的连接规范. socke实现了tcp协议开发.

  5. **应用层:** Http/ftp/..., 解释数据.





### 03. 浏览器请求一个URL的全过程

IP: 192.168.0.2

网关: 192.168.0.1

子网掩码: 255.255.255.0

DNS: 8.8.8.8

1. **DNS服务器/DNS缓存:** 解析URL拿到对应IP. 比如是192.169.0.2

2. 通过子网掩码与运算拿到IP的网络部分, 看是否属于子网内的机器. 发现不是

3. **打包数据包:** 通过以太网协议 给网关发送数据包 帧. 

   [链路层以太网数据帧 {IP网络层包 [TCP传输层包 (http应用层包)]}], 以太网会切包, 打到多个暴力.

   ![image-20210217224057551](%E7%AA%81%E5%87%BB2.assets/image-20210217224057551.png)

4. **网关转发-发送到对应IP的机器**

   ![image-20210217224748996](%E7%AA%81%E5%87%BB2.assets/image-20210217224748996.png)

### 04. TCP三次握手四次挥手? 为什么是三次?

- **三次握手:**

  ![image-20210217225925086](%E7%AA%81%E5%87%BB2.assets/image-20210217225925086.png)

- **为什么是三次握手:** 

  三次握手包含: client到server的连接请求和确认, server到client的连接请求和确认, 组成了三次. 保证了一次连接的双方都得到对方的确认. 

  四次握手也可以, 但是浪费了一次时间.

- **四次挥手:** 四次挥手没有把server确认和server请求断开两个绑定起来, 为了能够有一个单位的时间接收请求.

  ![03_tcp的4次挥手断开连接](%E7%AA%81%E5%87%BB2.assets/03_tcp%E7%9A%844%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5.png)





### 05. Socket 工作原理

TCP连接的具体实现是socket网络接口, 比如Java中的Socket是一个socket规范的实现, 负责

建立TCP连接和传输数据. 具体的就是

**封装TCP数据包到IP网络层数据包, 再到链路层的以太网addr数据包, 使用网卡发送和接收.**

![image-20210217231727223](%E7%AA%81%E5%87%BB2.assets/image-20210217231727223.png)



### 06. HTTP协议工作原理? Http1.1, 2.0区别?

HTTP依赖于TCP/IP技术栈, 本身是应用层的明文文本协议. 

- **文本协议内容:** 请求行, 请求头, 请求体
- **TCP/IP技术栈:** 
  - **封装流程:** HTTP请求报文->TCP数据包->IP数据包->以太网数据包
  - **传输流程:** 以太网协议+交换机 -> 网关 -> 目标网关 -> 机器 -> 拆包拿到数据.

1. HTTP1.0: 默认短链接.
2. HTTP1.1: 默认长连接. 多个HTTP请求走同一个TCP连接
3. **HTTP2.0: 多路复用**, 同一个TCP连接并行发送响应多个请求. **二进制分帧, 默认加密.**



### 07. HTTPS工作原理?

HTTPS = Http on STL. **加密过程使用了非对称加密协商对称加密密钥.** 

1. 协商加密规则: client发送自己支持的加密规则给server, server选择一套加密算法和验签算法.
2. server返回证书: 证书是一个证书链, client使用非对称加密算法校验证书链是否正确, 是否是正式颁布的公钥.
3. server和client通过公钥非对称加密来协商一个对称加密的密钥
4. 每次交互都会通过验签算法验证数据完整性.
5. **通过对称加密传输信息.**



### 08. HTTP长连接工作原理?

HTTP是文本传输协议, 本身基于TCP/IP技术栈, Http1.0的默认短链接是在每次传输完后都关闭TCP连接, 而TCP连接本身是长连接, 所以会造成浪费.

HTTP1.1的默认长连接就是保持TCP长连接, 多个HTTP请求走同一个TCP连接. 











## 11. 线上进程kill不掉

进程kill不掉变成僵尸进程. 

父子进程, 子进程结束得不到父进程确认, 就会变成僵尸进程.

1. ps -aux 查看stat = z的僵尸进程, 找到它的父进程
2. 先kill掉父进程, 再kill子进程.



### 12. 线上机器磁盘快满了怎么办?

1. `df -h ` 查看磁盘使用情况.
2. 各种日志过多删除一点, 写shell定时删除
3. `find / -size+100M | xargs ls -lh` 查看大于100M的文件.
4. `du -h >fs_du.log` 分析每个目录的磁盘大小.



### 13. 并发编程常见基础题 - TODO



























